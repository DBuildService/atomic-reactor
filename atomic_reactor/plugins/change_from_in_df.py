"""
Copyright (c) 2015-2022 Red Hat, Inc
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the LICENSE file for details.


Pre-build plugin that changes the parent images used in FROM instructions
to the more specific names given by the builder.
"""
from atomic_reactor.dirs import BuildDir
from atomic_reactor.plugin import Plugin
from atomic_reactor.util import base_image_is_custom, base_image_is_scratch


class BaseImageMismatch(RuntimeError):
    pass


class ParentImageUnresolved(RuntimeError):
    pass


class ParentImageMissing(RuntimeError):
    pass


class ChangeFromPlugin(Plugin):
    key = "change_from_in_dockerfile"
    is_allowed_to_fail = False

    def __init__(self, workflow):
        """
        constructor

        :param workflow: DockerBuildWorkflow instance
        """
        # call parent constructor
        super(ChangeFromPlugin, self).__init__(workflow)

    def _sanity_check(self, df_base, builder_base):
        image = self.workflow.data.dockerfile_images[df_base]
        if builder_base != image:
            # something updated parent_images entry for base without updating
            # the build's base_image; treat it as an error
            raise BaseImageMismatch(
                "Parent image '{}' for df_base {} does not match base_image '{}'"
                .format(image, df_base, builder_base)
            )

    def change_from_in_df(self, build_dir: BuildDir) -> None:
        self.log.info(
            "Updating FROM instructions in %s Dockerfile to pin parent images", build_dir.platform
        )
        dfp = build_dir.dockerfile

        df_images = self.workflow.data.dockerfile_images
        build_base = df_images.base_image

        if not df_images.base_from_scratch and not df_images.custom_base_image:
            # do some sanity checks to defend against bugs and rogue plugins
            self._sanity_check(dfp.baseimage, build_base)

        # check for lost parent images
        missing_set = set()
        for df_img in dfp.parent_images:
            if base_image_is_scratch(df_img):
                continue
            try:
                df_images[df_img]
            except KeyError:
                missing_set.add(df_img)
        if missing_set:
            # this would indicate another plugin modified parent_images out of sync
            # with the Dockerfile or some other code bug
            raise ParentImageMissing(f"Lost parent image(s) from Dockerfile images and their "
                                     f"parents:"
                                     f" {missing_set}")

        # replace image tags with manifest digests generated by check_base_image
        new_parents = []

        for df_img in dfp.parent_images:
            if base_image_is_scratch(df_img):
                new_parents.append(df_img)
            else:
                new_parents.append(df_images[df_img].to_str())

        # update parent_images in Dockerfile
        dfp.parent_images = new_parents

        if df_images.base_from_scratch:
            self.log.debug("base image '%s' left unchanged", dfp.baseimage)
        else:
            self.log.debug(
                "for base image '%s' using image with pullspec '%s'",
                dfp.baseimage, build_base
            )

    def run(self):
        """Run the plugin."""
        df_images = self.workflow.data.dockerfile_images

        self.log.info("parent_images '%s'", df_images.keys())
        unresolved = [
            key for key, val in df_images.items()
            if not base_image_is_custom(str(key)) and not val
        ]
        if unresolved:
            # this would generally mean check_base_image didn't run and/or
            # custom plugins modified parent_images; treat it as an error.
            raise ParentImageUnresolved("Parent image(s) unresolved: {}".format(unresolved))

        self.workflow.build_dir.for_each_platform(self.change_from_in_df)
