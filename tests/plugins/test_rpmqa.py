"""
Copyright (c) 2015 Red Hat, Inc
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the LICENSE file for details.
"""

import docker
from flexmock import flexmock
import pytest
import tarfile
from functools import partial
import subprocess

from atomic_reactor.inner import DockerBuildWorkflow
from atomic_reactor.plugin import PostBuildPluginsRunner, PluginFailedException
from atomic_reactor.plugins.post_rpmqa import (PostBuildRPMqaPlugin, RPMDB_DIR_NAME, RPMDB_PATH)
from atomic_reactor.utils.rpm import parse_rpm_output
from atomic_reactor.util import DockerfileImages
from tests.stubs import StubSource
from docker.errors import APIError

TEST_IMAGE = "fedora:latest"

PACKAGE_LIST = ['python-docker-py;1.3.1;1.fc24;noarch;(none);'
                '191456;7c1f60d8cde73e97a45e0c489f4a3b26;1438058212;(none);(none)',
                'fedora-repos-rawhide;24;0.1;noarch;(none);'
                '2149;d41df1e059544d906363605d47477e60;1436940126;(none);(none)',
                'gpg-pubkey-doc;1.0;1;noarch;(none);'
                '1000;00000000000000000000000000000000;1436940126;(none);(none)']
PACKAGE_LIST_WITH_AUTOGENERATED = PACKAGE_LIST + ['gpg-pubkey;qwe123;zxcasd123;(none);(none);0;'
                                                  '(none);1370645731;(none);(none)']
PACKAGE_LIST_WITH_AUTOGENERATED_B = [x.encode("utf-8") for x in PACKAGE_LIST_WITH_AUTOGENERATED]


pytestmark = pytest.mark.usefixtures('user_params')


def generate_archive(tmpdir, rpm_dir_exists=True, rpm_dir_empty=False):
    """Generate a fake tar archive
    :param bool rpm_dir_exists: wheter the archive contains rpm db directory.
    :param bool rpm_dir_empty: whether the rpm db directory in archive is empty.
    :rtype: generator
    """
    archive_path = tmpdir.join('temp.tar')
    if rpm_dir_exists:
        rpm_dir = tmpdir.join(RPMDB_DIR_NAME).mkdir()
        if not rpm_dir_empty:
            rpm_dir.join('Basenames').write('')
            rpm_dir.join('Dirnames').write('')
            rpm_dir.join('Packages').write('')

        with tarfile.open(str(archive_path), 'w') as archive_tar:
            archive_tar.add(rpm_dir, arcname=RPMDB_DIR_NAME)
    else:
        non_rpm_dir = tmpdir.join('non_rpm_dir').mkdir()
        with tarfile.open(str(archive_path), 'w') as archive_tar:
            archive_tar.add(non_rpm_dir, arcname='non_rpm_dir')

    with open(str(archive_path), 'rb') as f:
        for block in iter(partial(f.read, 8), b''):
            yield block
    archive_path.remove()


def mock_logs(cid, **kwargs):
    return b"\n".join(PACKAGE_LIST_WITH_AUTOGENERATED_B)


def mock_logs_raise(cid, **kwargs):
    raise RuntimeError


def mock_logs_empty(cid, **kwargs):
    return ''


def setup_mock_logs_retry(cache=None):
    cache = cache or {}
    cache.setdefault('attempt', 0)

    def mock_logs_retry(cid, **kwargs):
        if cache['attempt'] < 4:
            logs = mock_logs_empty(cid, **kwargs)
        else:
            logs = mock_logs(cid, **kwargs)

        cache['attempt'] += 1
        return logs

    return mock_logs_retry


def set_df_images(workflow, base_from_scratch=False):
    if base_from_scratch:
        workflow.dockerfile_images = DockerfileImages(['scratch'])
    else:
        workflow.dockerfile_images = DockerfileImages([])


@pytest.mark.skip(reason="plugin needs rework to get image content differently than via docker")
@pytest.mark.parametrize('base_from_scratch', [
    True,
    False,
])
@pytest.mark.parametrize("ignore_autogenerated", [
    {"ignore": True, "package_list": PACKAGE_LIST},
    {"ignore": False, "package_list": PACKAGE_LIST_WITH_AUTOGENERATED},
])
def test_rpmqa_plugin_success(caplog, tmpdir, base_from_scratch,
                              ignore_autogenerated):
    workflow = DockerBuildWorkflow(source=None)
    workflow.source = StubSource()
    set_df_images(workflow, base_from_scratch=base_from_scratch)

    # mock_stream = generate_archive(tmpdir)

    (flexmock(subprocess)
     .should_receive("check_output")
     .once()
     .and_return("\n".join(PACKAGE_LIST_WITH_AUTOGENERATED)))

    flexmock(docker.APIClient, logs=mock_logs)
    runner = PostBuildPluginsRunner(
        workflow,
        [{"name": PostBuildRPMqaPlugin.key,
          "args": {
              'image_id': TEST_IMAGE,
              "ignore_autogenerated_gpg_keys": ignore_autogenerated["ignore"]}}
         ])
    results = runner.run()

    assert results[PostBuildRPMqaPlugin.key] == ignore_autogenerated["package_list"]
    assert workflow.image_components == parse_rpm_output(ignore_autogenerated["package_list"])


@pytest.mark.skip(reason="plugin needs rework to get image content differently than via docker")
@pytest.mark.parametrize('base_from_scratch', [
    True,
    False,
])
def test_rpmqa_plugin_rpm_query_failed(caplog, tmpdir, base_from_scratch):
    workflow = DockerBuildWorkflow(source=None)
    workflow.source = StubSource()
    set_df_images(workflow, base_from_scratch=base_from_scratch)

    # mock_stream = generate_archive(tmpdir)

    runner = PostBuildPluginsRunner(
        workflow,
        [{"name": PostBuildRPMqaPlugin.key,
          "args": {
              'image_id': TEST_IMAGE,
              "ignore_autogenerated_gpg_keys": True}}
         ])

    log_msg_getting = 'getting rpms from rpmdb:'

    (flexmock(subprocess)
     .should_receive("check_output")
     .once()
     .and_raise(Exception, 'rpm query failed'))

    with pytest.raises(Exception, match='rpm query failed'):
        runner.run()
    assert log_msg_getting in caplog.text
    assert workflow.image_components is None
    log_msg = 'Failed to get rpms from rpmdb:'
    assert log_msg in caplog.text


@pytest.mark.skip(reason="plugin needs rework to get image content differently than via docker")
@pytest.mark.parametrize('base_from_scratch', [
    True,
    False,
])
def test_rpmqa_plugin_rpmdb_dir_is_empty(caplog, tmpdir, base_from_scratch):
    workflow = DockerBuildWorkflow(source=None)
    workflow.source = StubSource()
    set_df_images(workflow, base_from_scratch=base_from_scratch)

    # mock_stream = generate_archive(tmpdir, rpm_dir_empty=True)

    runner = PostBuildPluginsRunner(
        workflow,
        [{"name": PostBuildRPMqaPlugin.key,
          "args": {
              'image_id': TEST_IMAGE,
              "ignore_autogenerated_gpg_keys": True}}
         ])

    log_msg = f'rpmdb directory {RPMDB_PATH} is empty'
    if base_from_scratch:
        results = runner.run()
        assert log_msg in caplog.text
        assert results[PostBuildRPMqaPlugin.key] is None
        assert workflow.image_components is None
    else:
        with pytest.raises(PluginFailedException, match=log_msg):
            runner.run()
        assert log_msg in caplog.text
        assert workflow.image_components is None


@pytest.mark.skip(reason="plugin needs rework to get image content differently than via docker")
@pytest.mark.parametrize('base_from_scratch', [
    True,
    False,
])
@pytest.mark.parametrize('get_archive_raises', [APIError, Exception])
def test_rpmqa_plugin_get_archive_fails(caplog, tmpdir, base_from_scratch,
                                        get_archive_raises):
    workflow = DockerBuildWorkflow(source=None)
    workflow.source = StubSource()
    set_df_images(workflow, base_from_scratch=base_from_scratch)

    runner = PostBuildPluginsRunner(
        workflow,
        [{"name": PostBuildRPMqaPlugin.key,
          "args": {
              'image_id': TEST_IMAGE,
              "ignore_autogenerated_gpg_keys": True}}
         ])

    # response = flexmock(content="abc", status_code=123)

    if get_archive_raises == APIError:
        log_msg = 'Could not extract rpmdb in'
        if base_from_scratch:
            results = runner.run()
            assert log_msg in caplog.text
            assert results[PostBuildRPMqaPlugin.key] is None
            assert workflow.image_components is None
        else:
            with pytest.raises(PluginFailedException):
                runner.run()
            assert log_msg in caplog.text
            assert workflow.image_components is None

    elif get_archive_raises == Exception:
        with pytest.raises(Exception, match='get archive failed'):
            runner.run()
        log_msg = 'Get archive failed while extracting rpmdb in'
        assert log_msg in caplog.text
        assert workflow.image_components is None


def test_rpmqa_plugin_skip():
    """
    Test skipping the plugin if workflow.image_components is already set
    """
    workflow = DockerBuildWorkflow(source=None)
    workflow.source = StubSource()
    set_df_images(workflow)

    image_components = {
        'type': 'rpm',
        'name': 'something'
    }
    setattr(workflow, 'image_components', image_components)

    runner = PostBuildPluginsRunner(workflow,
                                    [{"name": PostBuildRPMqaPlugin.key,
                                      "args": {'image_id': TEST_IMAGE}}])
    results = runner.run()
    assert results[PostBuildRPMqaPlugin.key] is None
    assert workflow.image_components == image_components


@pytest.mark.skip(reason="plugin needs rework to get image content differently than via docker")
def test_rpmqa_plugin_exception():
    workflow = DockerBuildWorkflow(source=None)
    workflow.source = StubSource()
    set_df_images(workflow)

#    flexmock(docker.APIClient, logs=mock_logs_raise)
    runner = PostBuildPluginsRunner(workflow,
                                    [{"name": PostBuildRPMqaPlugin.key,
                                      "args": {'image_id': TEST_IMAGE}}])
    with pytest.raises(PluginFailedException):
        runner.run()
